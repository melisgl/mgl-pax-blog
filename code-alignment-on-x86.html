<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>Code alignment on x86</title>
<link type='text/css' href='style.css' rel='stylesheet'/>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<script src="jquery.min.js"></script>
<script src="toc.min.js"></script>
<script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [['$','$']],
         processEscapes: true
       }
     });
   </script>
   <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS_HTML">
   </script>
   </head>
<body>
<div id="content-container">
<div id="toc">
<div class="menu-block"><span class="menu-block-title">me</span><ul><li><a href="http://quotenil.com">blog</a></li><li><a href="mailto:mega@retes.hu">email</a></li><li><a href="http://github.com/melisgl/">git</a></li></ul></div><div id="page-toc">
</div>
<div id="toc-footer"><ul><li><a href="https://github.com/melisgl/mgl-pax">[generated by MGL-PAX]</a></li></ul></div>
</div>
<div id="content">
<p><a id='x-28MGL-PAX-BLOG-3A-40CODE-ALIGNMENT-ON-X86-20MGL-PAX-3ASECTION-29'></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#x-28MGL-PAX-BLOG-3A-40CODE-ALIGNMENT-ON-X86-20MGL-PAX-3ASECTION-29" title="Code alignment on x86">&#8634;</a></span></span></p>

<h1><a href="#x-28MGL-PAX-BLOG-3A-40CODE-ALIGNMENT-ON-X86-20MGL-PAX-3ASECTION-29">Code alignment on x86</a></h1>

<p><em>Tags</em>: <a href="category-lisp.html#x-28MGL-PAX-BLOG-3A-3A-40CATEGORY-LISP-20MGL-PAX-3ASECTION-29" title="Lisp">Lisp</a>, <a href="blog.html#x-28MGL-PAX-BLOG-3A-3A-40BLOG-20MGL-PAX-3ASECTION-29" title="Blog">Blog</a></p>

<p><em>2009-03-09</em> -- There has always been a lot of wiggling of SBCL
<a href="http://sbcl.boinkor.net/bench/" >boinkmarks</a> results. It's easy to
chalk this up to system load, but the same can be observed running
the <a href="http://common-lisp.net/project/cl-bench/" >cl-bench</a> benchmarks
under more ideal circumstances. Part of the reason is the
insufficient number of iterations of some tests: measurement
accuracy is really bad when the run time is below 0.2s and it is
abysmal when there is other activity on the system which is easy to
tell even in retrospect by comparing the real and user time columns.</p>

<p>But that's not the end of the story, take for instance
<code>FPRINT/PRETTY</code>: it takes more than two seconds but often
experiences changes up to 7% caused by seemingly unrelated changes.
People have fingered alignment as a likely cause.</p>

<p>Recently this issue has become more pressing as I've been trying to
reduce the overhead of x86's pseudo atomic. Unfortunately, the
effect is smallish which makes measurement difficult so I tried
aligning loops on 16 byte boundaries. This being on x86, that meant
aligning code similarly first (it's 8 byte aligned currently).</p>

<p>The <a href="http://quotenil.com/git/?p=sbcl.git;a=commit;h=2148639257c45f43c99f8c24087f17c9d8d03abb" >change
itself</a> (from
the allocate-code-object branch of my git tree) is rather trivial,
the effects are not. It turns out that depending on the
<a href="http://www.agner.org/optimize/microarchitecture.pdf" >microarchitecture</a>
some x86 CPUs like alignment, while the rest should really not care
much. In practice, other factors come into play at which
<a href="http://article.gmane.org/gmane.lisp.steel-bank.devel/12898" >we</a> can
only
<a href="http://groups.google.com/group/comp.lang.asm.x86/browse_thread/thread/bffd4ad26b9a9b10#" >guess</a>.
It certainly seems that the Core Duo (and likely the Pentium M) is
so deeply unnerved by a jump instruction near the end of a 16 byte
block that it cannot execute the loop at its normal speed.</p>

<p>This led to an experiment where the compiler was modified to pad
innermost loops with a few preceding NOPs so that their ends either
stay at least 3 bytes from the end of the block or spill over it by
at least one byte. However, on a <a href="http://quotenil.com/git/?p=sbcl.git;a=commitdiff;h=85529e0701c1855634ef1b119c1ac06b113a05db;hp=2148639257c45f43c99f8c24087f17c9d8d03abb" >quick and dirty
implementation</a>
of the above there is no discernible improvement. It may be that in
practice even the tightest loops are already longer than 16 bytes
...</p>

<p>For now, here are the cl-bench results from a 32 bit binary on an
<a href="blog-files/align-code/opteron-32bit-results" >Opteron</a>, a
<a href="blog-files/align-code/piii-results" >PIII</a>, a
<a href="blog-files/align-code/p4-results" >P4</a>, a <a href="blog-files/align-code/core-duo-results" >Core
Duo</a> system.</p>

<p>There may be a slight improvement but its magnitude is pretty small
compared to the noise. I'm declaring the evidence inconclusive and let
the commit stay out of the official SBCL tree.</p>
  </div>
</div>
<script>$('#page-toc').toc({'selectors': 'h1,h2,h3,h4'});</script>
</body>
</html>
