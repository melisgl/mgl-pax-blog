<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>Calling Convention Hacks</title>
<link type='text/css' href='style.css' rel='stylesheet'>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width">
   <script src="jquery.min.js"></script>
<script src="toc.min.js"></script>
<script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [['$','$']],
         processEscapes: true
       }
     });
   </script>
   <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
   </script>
   <!-- Google tag (gtag.js) -->
<script async src='https://www.googletagmanager.com/gtag/js?id=G-7X64Q1D73F'></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7X64Q1D73F');
</script>
<link rel='shortcut icon' type='image/png' href='favicon.png'>
<link rel='preconnect' href='https://fonts.googleapis.com'>
<link rel='preconnect' href='https://fonts.gstatic.com' crossorigin>
<link href='https://fonts.googleapis.com/css2?family=Gentium+Book+Plus:ital,wght@0,400;0,700;1,400;1,700&display=swap' rel='stylesheet'>
<style> @import url('https://fonts.googleapis.com/css2?family=Gentium+Book+Plus:ital,wght@0,400;0,700;1,400;1,700&display=swap'); </style>

</head>
<body>
<div id="content-container">
<div id=toc>
 <div id=home>
  <a href=blog.html>(QUOTE NIL)</a>
 </div>
 <div id=links>
  Ramblings on <a href=ai.html>ai</a>, <a href=lisp.html>lisp</a>, <a
  href=tech.html>tech</a> and <a href=personal.html>personal</a> topics by <a
  href=about-me.html>me</a>.
 </div>
</div><div id="content">
<p><a id="x-28MGL-PAX-BLOG-3A-40CALLING-CONVENTION-HACKS-20MGL-PAX-3ASECTION-29"></a>
<a id="MGL-PAX-BLOG:@CALLING-CONVENTION-HACKS%20MGL-PAX:SECTION"></a></p>

<h1><a href="calling-convention-hacks.html">Calling Convention Hacks</a></h1>

<p><em>Tags</em>: <a href="lisp.html" title="lisp"><code>lisp</code></a>, <em>Date</em>: <code>2009-04-19</code></p>

<p>SBCL's <a href="http://www.sbcl.org/sbcl-internals/Calling-Convention.html" >calling
convention</a>
is rather peculiar. Frames are allocated and mostly set up by the
caller. The new frame starts with a pointer to the old frame, then
comes the return address, an empty slot and the stack arguments (the
first three are passed in registers on x86).</p>

<p>Software archeology aside, the only reason I can see for this scheme
is that stack arguments are easier to manipulate when they are after
the return address, old frame pointer part, in particular tail calls
with any number of arguments can be made without re<code>[</code>al<code>]</code>locating
the frame.</p>

<p>The first step towards callee allocated frames is swapping the
return address and old fp slots. Asking an innocent question on
<code>#lisp</code> accomplished most of the work as <a href="http://www.lisphacker.com/" >Alastair
Bridgewater</a> had a patch for x86 against
a 0.9ish version that does exactly this.</p>

<p>Forward porting it to current SBCL was a breeze. Relatively
speaking, of course, because debugging cold init failures is never
pleasant. He also had another patch that biases the frame pointer to
point to the old fp slot instead of just before the return address.
This has the benefit of making Lisp and foreign frame layouts the
same which makes backtraces more reliable and allows external
debugging tools recognize all frames.</p>

<p>Callee allocated frames are still quite some way off, but while in
the area I sought a bit of optimization fun. With the return address
before old fp it is now possible to return with the idiomatic <code>POP
EBP, RET</code> sequence. Well, most of the time: when more multiple
values are returned than there are argument passing registers they
are placed on the stack exactly where the arguments normally reside.
Obviously, in this case the frame cannot be dismantled.</p>

<p>Strangely, turning these <code>JMP</code>s into <code>RET</code>s in multiple value return
has no measureable effect on performance even though it results in
more paired <code>CALL</code>s. What about the other way, addressing unpaired
<code>RET</code>s by turning <code>JMP</code>s to local call'ed functions into <code>CALL</code>s? I
tried a quick hack that <code>CALL</code>s a small trampoline that sets up the
return pc slot and <code>JMP</code>s to the target. With this small change a
number of benchmarks in the cl-bench suit benefit greatly: <code>TAK</code>,
<code>FIB</code>, <code>FIB-RATIO</code>, <code>DERIV</code>, <code>DIV2-TEST-2</code>, <code>TRAVERSE</code>, <code>TRIANGLE</code>
gain about 25-50%. See results for
<a href="blog-files/x86oid-calling-convention-p4-results.txt" >P4</a> and <a href="blog-files/x86oid-calling-convention-64bit-opteron-results.txt" >64 bit
Opteron</a>.</p>

<p>This should take off another chunk off the proposed and already
partly done Summer of Code
<a href="http://coding.derkeiler.com/Archive/Lisp/comp.lang.lisp/2006-03/msg00528.html" >project</a>
for improving the x86 and x86-64 calling convention although a nicer
solution may be possible. As to the future, it is unclear to me how
callee allocated frames would pan out. Code for the current batch of
changes is
<a href="http://quotenil.com/git/?p=sbcl.git;a=shortlog;h=x86-calling-convention" >here</a>.</p>
  </div>
</div>
<script>$('#page-toc').toc({'selectors': ''});</script>
</body>
</html>
