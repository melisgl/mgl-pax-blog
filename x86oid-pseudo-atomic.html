<!DOCTYPE html>
<html xmlns='http://www.w3.org/1999/xhtml' xml:lang='en' lang='en'>
<head>
<title>X86oid Pseudo Atomic</title>
<link type='text/css' href='style.css' rel='stylesheet'/>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
<script src="jquery.min.js"></script>
<script src="toc.min.js"></script>
<script type="text/x-mathjax-config">
     MathJax.Hub.Config({
       tex2jax: {
         inlineMath: [['$','$']],
         processEscapes: true
       }
     });
   </script>
   <script type="text/javascript" async
     src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML">
   </script>
   <link href="https://fonts.googleapis.com/css2?family=Literata:ital,opsz,wght@0,7..72,400;0,7..72,700;1,7..72,400;1,7..72,700&display=swap" rel="stylesheet">
<style> @import url('https://fonts.googleapis.com/css2?family=Literata:ital,opsz,wght@0,7..72,400;0,7..72,700;1,7..72,400;1,7..72,700&display=swap'); </style>

</head>
<body>
<div id="content-container">
<div id="toc">
<div class="menu-block"><span class="menu-block-title">Blog Categories</span><ul><li><a href="http://quotenil.com">'() blog</a></li><li><a href="http://quotenil.com/category-lisp.html">lisp</a></li><li><a href="http://quotenil.com/category-ai.html">ai</a></li><li><a href="http://quotenil.com/category-tech.html">tech</a></li><li><a href="http://quotenil.com/category-personal.html">personal</a></li></ul></div><div class="menu-block"><span class="menu-block-title">Me</span><ul><li><a href="mailto:mega@retes.hu">mega@retes.hu</a></li><li><a href="mega.gpg.asc">gpg key</a></li><li><a href="http://github.com/melisgl/">github/melisgl</a></li><li><a href="https://mastodon.social/@melisgl">mastodon.social/@melisgl</a></li><li><a href="https://twitter.com/GaborMelis">twitter/GaborMelis</a></li><li><a href="http://discord.com/users/melisgl#0879">discord/melisgl#0879</a></li><li><a href="https://www.linkedin.com/in/melisgabor/">linkedin/melisgabor</a></li></ul></div><div id="page-toc">
</div>
<div id="toc-footer"><ul><li><a href="https://github.com/melisgl/mgl-pax">[generated by MGL-PAX]</a></li></ul></div>
</div>
<div id="content">
<p><a id="x-28MGL-PAX-BLOG-3A-40X86OID-PSEUDO-ATOMIC-20MGL-PAX-3ASECTION-29"></a>
<a id="MGL-PAX-BLOG:@X86OID-PSEUDO-ATOMIC%20MGL-PAX:SECTION"></a></p>

<p><span class="outer-navigation"><span class="navigation"> <a href="#MGL-PAX-BLOG:@X86OID-PSEUDO-ATOMIC%20MGL-PAX:SECTION" title="X86oid Pseudo Atomic">&#8634;</a></span></span></p>

<h1><a href="#MGL-PAX-BLOG:@X86OID-PSEUDO-ATOMIC%20MGL-PAX:SECTION">X86oid Pseudo Atomic</a></h1>

<p><em>Tags</em>: <a href="lisp.html#MGL-PAX-BLOG:@LISP%20MGL-PAX:SECTION" title="Lisp">Lisp</a>, <em>Date</em>: 2009-03-29</p>

<p>The relatively recent
<a href="http://www.method-combination.net/blog/archives/2008/02/01/vm-tricks.html" >chit</a>
- <a href="http://www.pvk.ca/Blog/LowLevel/VM_tricks_safepoints.html" >chat</a>
about allocation and interrupts have had me looking at ways to speed
up pseudo atomic in SBCL.</p>

<pre><code><span class="code"> <span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> pseudo-atomic <span class="paren2">(<span class="code">&amp;rest forms</span>)</span>
  <span class="paren2">(<span class="code"><i><span class="symbol">with-unique-names</span></i> <span class="paren3">(<span class="code">label</span>)</span>
    `<span class="paren3">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">,label <span class="paren6">(<span class="code">gen-label</span>)</span></span>)</span></span>)</span>
       <span class="paren4">(<span class="code">inst or <span class="paren5">(<span class="code">make-ea <span class="keyword">:byte</span> <span class="keyword">:disp</span> <span class="paren6">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
             <span class="paren5">(<span class="code">fixnumize 1</span>)</span> <span class="keyword">:fs</span></span>)</span>
       ,@forms
       <span class="paren4">(<span class="code">inst xor <span class="paren5">(<span class="code">make-ea <span class="keyword">:byte</span> <span class="keyword">:disp</span> <span class="paren6">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
             <span class="paren5">(<span class="code">fixnumize 1</span>)</span> <span class="keyword">:fs</span></span>)</span>
       <span class="paren4">(<span class="code">inst jmp <span class="keyword">:z</span> ,label</span>)</span>
       <span class="comment">;; if PAI was set, interrupts were disabled at the same
</span>       <span class="comment">;; time using the process signal mask.
</span>       <span class="paren4">(<span class="code">inst break pending-interrupt-trap</span>)</span>
       <span class="paren4">(<span class="code">emit-label ,label</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>EBP</h3>

<p>My first idea was that ORing is unnecessary since with the slew of
interrupt fixes going into 1.0.26 every interrupt deferred by pseudo
atomic is handled as soon as we leave the pa section. Hence, a
simple MOV would suffice. Or if we wanted to be fancy we could rely
on the fact that within SBCL <code>EBP</code> is always even (that leaves the
first bit of <code>PSEUDO-ATOMIC-BITS</code> for the interrupted flag) and
non-zero:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> pseudo-atomic <span class="paren2">(<span class="code">&amp;rest forms</span>)</span>
 <span class="paren2">(<span class="code"><i><span class="symbol">with-unique-names</span></i> <span class="paren3">(<span class="code">label</span>)</span>
   `<span class="paren3">(<span class="code"><i><span class="symbol">let</span></i> <span class="paren4">(<span class="code"><span class="paren5">(<span class="code">,label <span class="paren6">(<span class="code">gen-label</span>)</span></span>)</span></span>)</span>
      <span class="paren4">(<span class="code">inst mov <span class="paren5">(<span class="code">make-ea <span class="keyword">:dword</span> <span class="keyword">:disp</span> <span class="paren6">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
            ebp-tn <span class="keyword">:fs</span></span>)</span>
      ,@forms
      <span class="paren4">(<span class="code">inst xor <span class="paren5">(<span class="code">make-ea <span class="keyword">:dword</span> <span class="keyword">:disp</span> <span class="paren6">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
            ebp-tn <span class="keyword">:fs</span></span>)</span>
      <span class="paren4">(<span class="code">inst jmp <span class="keyword">:z</span> ,label</span>)</span>
      <span class="comment">;; if PAI was set, interrupts were disabled at the same time
</span>      <span class="comment">;; using the process signal mask.
</span>      <span class="paren4">(<span class="code">inst break pending-interrupt-trap</span>)</span>
      <span class="paren4">(<span class="code">emit-label ,label</span>)</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>This shaves a few bytes off the code and is an overall 0.5% win in
cl-bench (see &quot;pseudo-atomic.ebp&quot; in the
<a href="blog-files/pseduo-atomic/p4-results.txt" >results</a>).</p>

<h3>mprotect</h3>

<p>But if the page of <code>PSEDUO-ATOMIC-BITS</code> is made write protected
when an interrupt is deferred, then the pending interrupt can be run
from the sigsegv handler where we land coming out of pseudo atomic:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> pseudo-atomic <span class="paren2">(<span class="code">&amp;rest forms</span>)</span>
 `<span class="paren2">(<span class="code"><i><span class="symbol">progn</span></i>
    <span class="paren3">(<span class="code">inst mov <span class="paren4">(<span class="code">make-ea <span class="keyword">:dword</span> <span class="keyword">:disp</span> <span class="paren5">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
          ebp-tn <span class="keyword">:fs</span></span>)</span>
    ,@forms
    <span class="paren3">(<span class="code">inst xor <span class="paren4">(<span class="code">make-ea <span class="keyword">:dword</span> <span class="keyword">:disp</span> <span class="paren5">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
          ebp-tn <span class="keyword">:fs</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>And four more bytes are saved, making the total overhead of pseudo
atomic 12 bytes (+2 bytes with threads). This version is labelled
&quot;pseudo-atomic.mprotect.ebp&quot; and is not faster than the previous one.
Somewhat suprisingly, this variant (&quot;pseudo-atomic.mprotect.mov&quot;) is
just as fast:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> pseudo-atomic <span class="paren2">(<span class="code">&amp;rest forms</span>)</span>
 `<span class="paren2">(<span class="code"><i><span class="symbol">progn</span></i>
    <span class="paren3">(<span class="code">inst mov <span class="paren4">(<span class="code">make-ea <span class="keyword">:byte</span> <span class="keyword">:disp</span> <span class="paren5">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
          2 <span class="keyword">:fs</span></span>)</span>
    ,@forms
    <span class="paren3">(<span class="code">inst mov <span class="paren4">(<span class="code">make-ea <span class="keyword">:byte</span> <span class="keyword">:disp</span> <span class="paren5">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
          0 <span class="keyword">:fs</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<h3>Direction flag</h3>

<p>Another idea is to hijack the direction
flag:</p>

<pre><code><span class="code"><span class="paren1">(<span class="code"><i><span class="symbol">defmacro</span></i> pseudo-atomic <span class="paren2">(<span class="code">&amp;rest forms</span>)</span>
 `<span class="paren2">(<span class="code"><i><span class="symbol">progn</span></i>
    <span class="paren3">(<span class="code">inst std</span>)</span>
    ,@forms
    <span class="paren3">(<span class="code">inst cld</span>)</span>
    <span class="paren3">(<span class="code">inst mov <span class="paren4">(<span class="code">make-ea <span class="keyword">:byte</span> <span class="keyword">:disp</span> <span class="paren5">(<span class="code">* 4 thread-pseudo-atomic-bits-slot</span>)</span></span>)</span>
          0 <span class="keyword">:fs</span></span>)</span></span>)</span></span>)</span></span></code></pre>

<p>where the mov instruction sigsegvs if pseudo atomic was interrupted.
This is little more than a quick hack to gauge expected performance,
because SBCL itself uses the direction flag in a number of places,
to say nothing about alien land. However, there seems to be no
reason to pursue this further as its performance disappoints.</p>

<p>All in all, I have expected more gains, in particular I'm
disappointed by the performance of the mprotect trick. Still 0.5% is
okay for such a small change. Code is available
<a href="http://quotenil.com/git/?p=sbcl.git;a=shortlog;h=pseudo-atomic" >here</a> (from
the pseudo-atomic branch of my git tree).</p>
  </div>
</div>
<script>$('#page-toc').toc({'selectors': 'h1'});</script>
</body>
</html>
